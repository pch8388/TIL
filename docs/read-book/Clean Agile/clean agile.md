# 애자일 소개
- 폭포수 모델이 굉장히 오랫동안 소프트웨어 시장을 지배하였지만 소프트웨어를 개발하기에 좋은 방법이 아니다.
- 소프트웨어 프로젝트를 진행함에 있어 초기에 확정할 수 있는 것은 마감기일뿐이다.
- 모든 프로젝트는 좋음, 빠름, 저렴함, 완성 중의 세가지만 가질 수 있다.
- 애자일은 프로젝트 진행에 관한 전반적인 데이터를 가지고, 추 후의 일정을 계속 수정해나가며 개발을 진행한다.

## 애자일 개요
- 1주~2주 정도의 반복주기(혹은 스프린트라고 부름)를 가짐
- 반복주기 0 : 스토리(기능목록)을 만듬 => 끊임없는 분석과 설계
- 반복주기 1 : 스토리를 몇 개나 완료할 수 있을 지 추산, 스토리를 완료하는 데 필요한 일을 함
  - 반복주기를 진행하며 업무의 진행속도 등에 대한 데이터를 수집한다
  - 수집된 데이터를 바탕으로 추후 프로젝트 진행속도를 예측할 수 있다
  - 예측은 항상 빗나갈 수 있다
- 애자일은 데이터를 만든다 => 데이터는 희망이 아닌 관리를 하게 한다(희망은 프로젝트를 죽게 만든다)
- 품질의 하락은 최종적으로는 항상 프로젝트의 생산성을 떨어뜨린다. 조정할 수 있는 것은 프로젝트의 범위이다. => 반드시 필요한 기능들만 추려서 릴리즈 함으로써 기한을 맞춘다.

### Circle of Life(XP practice)
세 개의 고리
- 첫번째 고리 : 비즈니스와 관련된 XP 실천방법, 소프트웨어 개발팀이 다른 부서와 의사소통하는 방법과 관리하면서 지켜야할 원칙
  - planning game(계획 게임)
  - small release(작은 릴리스)
  - acceptance test(인수 테스트)
  - whole team(전체 팀)
- 두번째 고리 : 팀과 관련된 실천 방법, 개발팀을 관리하고 팀원들이 서로 의사소통하는 체계와 원칙
  - sustainable pace(지속 가능한 속도)
  - collective ownership(공동 소유)
  - continuous integration(지속적 통합)
  - metaphor(메타포)
- 세번째 고리 : 기술 실천 방법, 프로그래머가 기술적인 품질을 가장 높게 유지하는 원칙
  - pairing(짝 프로그래밍)
  - simple design(단순한 설계)
  - refactoring(리팩토링)
  - test driven development(테스트 주도 개발)

## 애자일 정신을 나타내는 네가지 문장
- 공정과 도구보다 개인과 상호작용
  - whole team, metaphor, pairing, sustainable pace
- 포괄적인 문서보다 작동하는 소프트웨어
  - acceptance test, test driven development, simple design, refactoring, continuous integration
- 계약 협상보다 고객과의 협력
  - small release, planning game, acceptance test, metaphor
- 계획을 따르기보다 변화에 대응하기
  - small release, planning game, test driven development, refactoring, acceptance test

# 왜 애자일인가
직업의식과 고객의 당연한 기대 때문

## 직업의식
- 애자일은 전문가가 되겠다는 약속 => 자신의 수준을 올리겠다는 약속
- 소프트웨어는 현재 모든 곳에서 사용되고 매우 중요한 일들을 처리, 전문가로서 결국 소프트웨어에 대한 책임은 개발자가 가져야 한다

## 당연한 기대
- 고객이 제품의 퀄리티를 기대하는 것은 당연하다
- 개발자는 기술적으로 준비된 상태를 유지해야 한다 => 배포주기에 따라 항상 기술적으로는 릴리스 할 수 있도록 준비되어야 한다
- 안정적 생산성을 유지해야한다 => 코드 품질 등이 하락하면 생산성이 지속적으로 하락한다
- 낮은 수정 비용을 가져야한다
- 짝 프로그래밍, 테스트 주도 개발, 리팩터링, 단순한 설계를 통하여 지속적인 개선을 해야한다
- QA 는 시스템적인 문제를 찾지 못해야 한다. 만약 찾는다면 개발 프로세스의 문제를 의심해보아야 한다. => QA 는 개발이 끝난 후가 아니라 어떤 자동 테스트를 만들어야 할 지 같이 고민하는 역할이 더 어울린다. 즉, 수동 테스트는 최대한 줄이는 것이 좋다
- 하나의 팀처럼 행동해야 한다
- 정확한 추정을 해야한다 => 아는 것을 토대로 모르는 것을 추정해야 한다
- 진짜 대답이 아니요 일때는 아니요라고 할 수 있어야 한다
- 지속적이고 적극적인 학습을 해야한다
- 서로를 멘토링할 수 있어야 한다

## 권리장전
### 고객 권리 장전
- 전체 계획을 알 권리 : 무엇을, 언제, 얼마의 비용으로 완성할 수 있는 지
- 반복 주기마다 가능한 한 많은 가치를 얻을 권리
- 작동하는 시스템을 통해 진척도를 알 권리 : 개발자는 고객이 제공한 테스트로 계속해서 시스템을 검사하여 동작을 증명
- 과도한 비용 추가 없이 기능이나 우선순위를 바꿀 권리
- 일정이나 추정이 바뀐 경우 제때 알림을 받고, 일정을 맞추기 위한 업무 범위를 조정할 권리, 언제든지 프로젝트를 취소할 권리

### 개발자 권리 장전
- 명확하게 정의된 우선순위와 함께 무엇이 필요한지를 알 권리
- 언제나 높은 품질의 결과물을 만든 권리
- 동료나 관리자, 고객에게 도움을 요청하고 받을 권리
- 자신만의 추정치를 만들고 갱신할 권리
- 담당 업무를 할당받는 게 아니라 수락할 권리

# 비지니스 실천 방법
## 계획 세우기
- 프로그래머는 프로젝트를 매우 작은 조각으로 잘게 자르는 일을 한다 => 코드로 한줄한줄 표현
- 프로젝트 계획을 세울 때는 확실한 시간 범위를 산정하고 이 시간 범위를 가능한 줄이기 위해 약간의(너무 많지 않은) 시간을 투자하는 것이다.
  - 확실하게 끝날 수 있는 시간의 범위를 추정하자는 의미인데, 사실 프로젝트는 유동적으로 변하기 때문에 이 범위도 시간의 흐름에 따라 유동적으로 변한다고 할 수 있다.
- 삼변량 추정(trivariate estimation)
  - 최선, 보통, 최악의 경우의 일정으로 추정하는 방법
  - PERT 기법으로 관리할 수 있다.
  - 정밀도가 낮음
- 스토리 포인트(story point)
  - 특정 스토리마다 포인트를 부여하는 기법
  - 부여된 포인트들은 해결하기 위한 노력의 추정치
  - 특정 스토리를 해결하면 그 스토리에 부여된 포인트에 따라 다른 스토리들도 일정을 추정해 볼 수 있다. => 이것 또한 추정치이기 때문에 틀릴 수 있음, 데이터들을 쌓아감으로써 추정치의 정확도를 올려야함
  - 스토리의 포인트를 부여할 때도 민주적인 방법을 사용하여야 하며, 반복주기의 중간에 해결된 스토리 포인트를 보고 남은 기간동안에 해결할 수 있는 포인트를 예측하여 조절한다. 즉, 반복주기동안에도 유동적으로 계획을 변경한다

### 스토리
- 사용자 스토리는 기능을 기억하기 위해 짧게 설명을 씀
- 세부사항은 추후에 인수테스트로 작성
- 스토리를 쓸때 지켜야할 여섯가지(INVEST)
  - I(독립적인 Independent) : 사용자 스토리는 서로 독립적 => 구현하는 데 순서에 구애받지 않아야 함(실질적으로는 순서에 구애받는 경우가 많으나 최대한 의존성을 줄이자)
  - N(협살할 수 있는 Negotiable) : 개발자와 사업부서가 세부사항을 협상
  - V(가치 있는 Valuable) : 명확하고 계량할 수 있는 비즈니스 가치가 있어야 함
  - E(추정할 수 있는 Estimable) : 개발자가 작업량을 추정할 수 있게 구체적이어야 함
  - S(작은 Small) : 개발자 한두 명이 반복주기 한 번 이내에 구현하기 힘들정도로 크면 안됨
  - T(테스트 할 수 있는 Testable) : 사업 부서가 스토리 완료를 증명하는 테스트를 제시할 수 있어야 함
- 쪼갤 수 없는 스토리는 거의 없음
- 스토리의 크기를 작고 명확하게 유지하는 것이 좋음
- 스파이크 : 메타스토리 => 기간 산정이 힘든 (학습이 필요하다던가 하는) 스토리

### 반복주기 관리
스토리는 반복주기 안에서 완료되는 것이 좋다. 두 개의 스토리를 50% 씩 달성하는 것보다 한개의 스토리를 완성시키는 것이 더 좋다.

### 인수 테스트
- QA 가 인수테스트를 작성하지 않았다면 계획 회의가 끝나자마자 작성해야한다.
- QA 와 개발자가 인수 테스트를 짝프로그래밍으로 만드는 것도 좋다.
- 반복주기의 중반이 되었는데도 인수테스트가 작성되지 않았다면 개발자도 도와야한다.
  - 이런일이 자주 발생한다면 QA 와 개발자의 비율이 맞지 않는 지 고민해봐야함
- 반복주기가 종료되기 전에 인수테스트 작성이 끝났다면 다음 주기에 실행할 인수테스트를 미리 추정하여 작성한다.
  - 불확실하더라도 미리 작성해 두는 것이 좋음
- 개발자와 QA 는 인수 테스트를 작성하며 지속적인 커뮤니케이션을 해야한다.

### 속도
- 반복주기에서 업무 처리 속도가 떨어진다는 것은 코드 품질에 문제가 있을 가능성이 큼
  - 리팩터링이 충분하지 않을 가능성을 고려
    - 테스트코드가 적어서 리팩터링이 두려울 수 있다
- 속도가 오른다면 관리자의 압박에 개발자들이 스토리의 포인트를 높게 산정하는 것일 수 있다
- 속도가 느리거나 빠르다고 반복주기가 실패한 것이 아니라 반복주기에서 데이터를 획득하지 못하는 것이 실패하는 것이다.
- 반복주기가 여러회 반복되다보면 속도의 기울기는 0에 가까워져야한다.

> 기준스토리와 지속적으로 비교하며 스토리 인플레이션이 발생하지 않도록 주의해야한다.

## 작은 릴리스
- 개발팀이 소프트웨어를 자주 릴리스 해야 함
  - 기술적으로 릴리스가 자주 일어나야하고, 실제로 반영하는 것은 사업상의 결정
  - 지속적 배포(Continuous Delivery)를 짧은 주기로 해야함

## 인수 테스트
- 사업부서가 요구사항을 명시해야 함
- BDD(Behavior-Driven Development) 기반으로 작성하면 좋음
- 업무분석가와 QA가 작성
- 인수테스트로 반복주기의 스토리 완료 여부 판명
- QA 의 업무가 프로젝트의 종료단계가 아닌 시작단계에서 실행되게 됨
- 지속적인 빌드(continuous Build)를 통해 자동화된 테스트를 지속적으로 실행

## 전체팀
- 고객(제품책임자 Product Owner)과 개발팀이 하나의 팀으로서 가까이에서 지속적으로 의견을 주고받으며 일하는 것이 이상적이다.

# 팀 실천 방법
## 메타포
어떠한 개념에 대한 용어의 정의를 말하는 데, 이러한 용어는 모두 이해하기 쉬워야 한다. 모든 사람이 동의하는 언어로 표현되어야 하고 DDD 에서는 이것을 유비쿼터스 언어라고 부른다(Ubiquitous Language)

## 지속 가능한 속도
프로젝트는 지속 가능한 속도로 진행해야한다. 근무 시간을 과도하게 초과하여 휴식을 충분히 취하지 못하면 집중력이 저하되고 오히려 생산성이 떨어진다. 흔히들 SI 의 가장 큰 문제점이라고들 말하는 보여주기식 야근 문화를 생각해보면 지속 가능한 속도를 유지하는 것이 얼마나 중요한 일인지 알 수 있다.

## 공동 소유
누군가 코드를 소유하고 공유하지 않으면 암묵적인 계급 체계가 생길 수 있다. 이것은 특정 계층이 많은 권리를 갖고 서로간의 불신을 만든다. 코드와 정보는 모두가 공유해아하고 투명해야한다. 전 직장에서 근무할 때 가장 문제라고 여겼던 것이 정보의 독점화였다.(PM이 정보를 매우 한정적으로만 공유)

## 지속적 통합
지속적인 통합을 위해 브랜치로 머지시키는 작업을 꾸준히 자주 일어나야한다. 이를 통해 지속적인 빌드를 수행(젠킨스등의 도구 사용)해야 하며 빌드가 자주 일어나면 테스트가 자주 수행되고 빌드가 깨지는 지 확인하기 쉽다. 이 때 빌드 수행을 위해 실패하는 테스트를 억지로 무시하는 것은 재앙을 불러 올 수 있다.

## 스탠드업 미팅
스탠드업 미팅은 몇가지 원칙을 지켜야한다.
- 미팅 참석은 필수가 아님
- 매일 할 필요없이 일정에 맞게 잡는다
- 10분안으로 무조건 끝낸다. 팀의 규모에 상관없이
- 회의 진행 방식은 단순하게 3가지 질문과 답만 한다(간단하게)
  1. 지난 스탠드업 미팅 이후 한일
  2. 다음 스탠드업 미팅까지 할일
  3. 어떤 장애물이 있는지
- 스탠드업 미팅은 개발자만 말해야한다.(다른 직군도 참여는 가능하지만 대화에 끼어들어서는 안됨)

# 기술 실천 방법
## 테스트 주도 개발
- 테스트를 먼저 작성함으로써 안정적인 코드를 생산할 수 있다
- 테스트를 후에 작성하면 핑계를 대며 테스트를 작성하지 않게 될 수 있다
  - 결국 테스트를 작성하지 않아 리팩터링 등에 두려움을 갖게 된다
- 테스트를 먼저 작성하여 코드 구조 등에 대해서도 미리 고민해볼 수 있다
- 테스트 주도 개발을 하게 되면 디버깅 할일이 줄어든다. 코드 검증에 대한 탄탄한 테스트가 존재하면 디버거 기능을 이용하는 빈도가 줄어들 것이다.
- 테스트 코드만 보면 어떻게 코드를 사용해야 하는 지, 발생할 수 있는 예외 등에 대해서도 알 수 있게 되어 문서화 효과를 얻을 수 있다.

## 리팩터링
- 리팩터링은 테스트 주도 개발의 한 사이클로 포함시킬 수 있을 만큼 밀접한 연관이 있다. 
- 리팩터링을 하기 위해서는 튼튼한 테스트 코드가 필요하고, TDD 를 공부할 때 사용했던 red-green-refactoring 의 사이클로 개발하는 것이 좋다. 
- 설계 변경등의 큰 변경이 있을 때도 테스트 코드를 바탕으로 리팩터링해야한다. 인수테스트 공부시 사용했던 방법인 작동하는 코드와 새로 설계하는 코드를 공존시키는 방법을 사용하는 것이 좋다. 즉, 설계를 변경하는 큰 변화가 있는 동안에도 지속적인 통합과 성공하는 빌드는 필수라는 것이다.

## 단순한 설계
- 리팩터링의 목표 중 하나
- 단순한 설계 규칙
  1. 모든 테스트를 통과할 것
  2. 의도를 드러낼 것
  3. 중복을 없앨 것
  4. 구성 요소를 줄일 것

## 짝 프로그래밍
- 반드시 해야하는 것은 아니다
- 한명이 드라이버, 한명이 네비게이터 라는 널리 알려진 방식으로 해도 되지만 꼭 그래야 하는 것은 아니다
- 일정을 따로 잡지 않는다
- 너무 길지않은 시간동안 한다
- 짝 프로그래밍은 구성원끼리 지식 공유를 위한 좋은 방법이다

# 애자일 해지기
## 애자일의 가치
- 용기 : 합리적인 정도로 위험을 감수
- 소통 : 모든 팀원(개발자, 고객, 테스터, 관리자)이 원할하게 커뮤니케이션(밥은 대면 소통이 좋다고 한다)
- 피드백 : 중요한 결정을 내리는 사람에게 빠른 피드백을 제공하는 것이 애자일의 가장 중요한 가치
- 단순함 : 코드를 단순하게 유지하고 팀은 더욱 단순하게 유지
- 기술 실천 방법은 반드시 수행해야한다. 이것을 전제조건으로 애자일을 도입할 수 있다. 모든 방법을 한번에 도입할 수 없다. 서서히 문화를 바꿔가는 것에 모든 조직의 합의가 필요하다.
- 애자일로의 전환의 장벽은 중간관리계층이다. 기존의 팀을 애자일하게 전환하는 것보다 새롭게 편성한 팀으로 애자일을 도입하는 것이 더욱 비용이 적게 든다.(하지만 항상 그럴수는 없을 것이다)

## 애자일 코치
애자일 코치가 항상 필요하지 않다. 밥이 얘기하는 애자일 코치는 애자일한 프로세스를 도와주는 존재이며, 외부에 특별히 드러나지 않아야 한다고 한다. 팀의 구성원으로서 애자일 문화를 도입하는 데 도움을 주어야지 관리자가 그 역할을 맡거나 코치가 관리를 하게 되면 실패하는 애자일이 되기 쉽다고 조언한다.

## 대규모 애자일
대규모 팀에서의 애자일은 힘들다. 이미 대규모팀의 문제는 해결되어있다고 생각할 수 있다. 오랜세월동안 특정한 문제를 큰 팀으로서 해결해왔기 때문이라고 한다. 개인적인 생각으론 조직문화 전체가 애자일하게 움직여야 될 거 같은데 책에서는 다르게 말해서 의외라는 생각이 들었다.
어쨋든, 밥은 책에서 대규모 애자일은 소규모의 팀들이 애자일하게 움직이고, 전체 조직에 대한 관리 노하우는 전통적인 방법을 사용하라고 조언한다.

## 애자일 도구
- 소프트웨어 개발자는 핵심 도구에 반드시 익숙해야 한다
  - 최소 한가지 프로그래밍 언어
  - IDE, 코드 편집기
  - 다양한 데이터 형식(json, xml, yaml), html 등의 마크업 언어
  - 운영 체제 명령줄 및 스크립트
  - git
  - 지속적 통합/빌드 도구(jenkins, teamcity)
  - 배포/서버 관리 도구(docker, k8s, ansible, chef, puppet)
  - 의사 소통 도구(email, slack, English)
  - 테스트 도구(Junit, cucumber, selenium)
- 훌륭한 도구의 조건
  - 금방 충분히 잘 배울 수 있다
  - 사용법이 명료해서 도구에 신경 쓰지 않고 쓸 수 있게 된다
  - 적응 또는 확장적응한다
  - 가격이 적절하다
  - 사람들이 원하는 일을 성취하도록 돕는다

## 코치하기 - 데이먼 풀
데이먼 풀은 애자일 코치에 대해 밥과 다른 견해를 보인다(항상 모든이의 생각이 같은 수 없고, 정답도 없다)
- 애자일 코치는 이미 자리잡고 있는 믿음과 문화, 프로세스, 생각, 일하는 방식을 모두 바꿀수 있게 돕는다
- 애자일 개별 실천방법
  - 칸반 실천 방법 : 벽에 칸반보드를 붙여 업무를 시각화, 진행 업무 수 제한, 시스템을 통해 업무 시작하기
  - 스크럼과 XP 실천 방법 : 짧은 일일 팀회의, 스크럼마스터, 회고, 교차기능팀, 사용자 스토리, 작은 릴리스, 리팩터링, TDD, 짝 프로그래밍
  - 팀 일정 맞추기 : 일일 회의로 체계적으로 장애물을 모아서 보고 경로를 따라 상위조직장에게 보고하고, 반복주기 길이뿐 아니라 시작과 완료일정 맞추기
  - 장애물 보고 경로 : 일하다가 맞딱드린 장애물을 바로바로 보고하여 최대한 빨리 가장 높은 가치를 만드는 일을 재개한다
  - 정기적인 팀 간 소통
  - 포트폴리오 칸반 : 동시에 진행하는 프로젝트의 수를 줄여 여러팀의 업무 조정이 쉬워지고 조정이 필요없을 수 있음. 최소 기능 개선(Minimum Viable Increments)과 함께 사용
  - 최소 기능 개선 : 가장 빠른 시간 안에 가장 높은 가치를 창출하는 최단 경로 찾기(지속적 배포, 작은 릴리스)
- 작은 것에 집중 : 결국 작은 단위로 작업간 의존성을 낮춰 빠른 피드백을 받는 방식이다 
  - SOLID 원칙
  - 작고 가치 잇는 사용자 스토리
  - 작은 릴리스 자주 하기
  - 지속적 통합
  - 단순한 설계

# 회고
책을 읽으며, 읽고나서 느낀 점에 대해 회고한다
- 애자일은 만능이 아니다
- 책의 내용을 모두 도입하는 것은 굉장히 힘들다. 작은 단위의 조직을 책에 나온정도로 체계적으로 구성하기가 힘듬
  - 사업부서와 개발부서, QA 등이 하나의 팀으로서 일하는 회사는 적어도 국내에서는 손꼽을 것 같다
  - 인수테스트와 같이 여러 직군이 짝 프로그래밍 혹은 협업해야 하는 프로세스를 실행하기는 엄청나게 힘들다고 생각된다
- 책의 초반부를 읽을 때는 환상에 빠진듯한 기분이 들었다.
- 책의 후반부로 갈수록 이상적이지만 현실가능성이 낮은 방법론이라는 생각이 들었다.
- 회고의 결론을 내리면 개발자로서는 기술 실천 방법에 나와있는 방법들에 대해 항상 고민하고 연구하여 도입할 수 있도록 노력해야 할 것이고, 이상적인 애자일을 추구하는 방향으로 프로젝트를 진행하는 것이 좋을 것 같다. 이상과 현실은 항상 다르지만 이상에 근접할 수 있도록 문화를 만드는 것이 소프트웨어로 돈을 버는 프로의 자세가 아닐까 하고 생각해보았다.