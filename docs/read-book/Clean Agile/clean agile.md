# 애자일 소개
- 폭포수 모델이 굉장히 오랫동안 소프트웨어 시장을 지배하였지만 소프트웨어를 개발하기에 좋은 방법이 아니다.
- 소프트웨어 프로젝트를 진행함에 있어 초기에 확정할 수 있는 것은 마감기일뿐이다.
- 모든 프로젝트는 좋음, 빠름, 저렴함, 완성 중의 세가지만 가질 수 있다.
- 애자일은 프로젝트 진행에 관한 전반적인 데이터를 가지고, 추 후의 일정을 계속 수정해나가며 개발을 진행한다.

## 애자일 개요
- 1주~2주 정도의 반복주기(혹은 스프린트라고 부름)를 가짐
- 반복주기 0 : 스토리(기능목록)을 만듬 => 끊임없는 분석과 설계
- 반복주기 1 : 스토리를 몇 개나 완료할 수 있을 지 추산, 스토리를 완료하는 데 필요한 일을 함
  - 반복주기를 진행하며 업무의 진행속도 등에 대한 데이터를 수집한다
  - 수집된 데이터를 바탕으로 추후 프로젝트 진행속도를 예측할 수 있다
  - 예측은 항상 빗나갈 수 있다
- 애자일은 데이터를 만든다 => 데이터는 희망이 아닌 관리를 하게 한다(희망은 프로젝트를 죽게 만든다)
- 품질의 하락은 최종적으로는 항상 프로젝트의 생산성을 떨어뜨린다. 조정할 수 있는 것은 프로젝트의 범위이다. => 반드시 필요한 기능들만 추려서 릴리즈 함으로써 기한을 맞춘다.

### Circle of Life(XP practice)
세 개의 고리
- 첫번째 고리 : 비즈니스와 관련된 XP 실천방법, 소프트웨어 개발팀이 다른 부서와 의사소통하는 방법과 관리하면서 지켜야할 원칙
  - planning game(계획 게임)
  - small release(작은 릴리스)
  - acceptance test(인수 테스트)
  - whole team(전체 팀)
- 두번째 고리 : 팀과 관련된 실천 방법, 개발팀을 관리하고 팀원들이 서로 의사소통하는 체계와 원칙
  - sustainable pace(지속 가능한 속도)
  - collective ownership(공동 소유)
  - continuous integration(지속적 통합)
  - metaphor(메타포)
- 세번째 고리 : 기술 실천 방법, 프로그래머가 기술적인 품질을 가장 높게 유지하는 원칙
  - pairing(짝 프로그래밍)
  - simple design(단순한 설계)
  - refactoring(리팩토링)
  - test driven development(테스트 주도 개발)

## 애자일 정신을 나타내는 네가지 문장
- 공정과 도구보다 개인과 상호작용
  - whole team, metaphor, pairing, sustainable pace
- 포괄적인 문서보다 작동하는 소프트웨어
  - acceptance test, test driven development, simple design, refactoring, continuous integration
- 계약 협상보다 고객과의 협력
  - small release, planning game, acceptance test, metaphor
- 계획을 따르기보다 변화에 대응하기
  - small release, planning game, test driven development, refactoring, acceptance test

# 왜 애자일인가
직업의식과 고객의 당연한 기대 때문

## 직업의식
- 애자일은 전문가가 되겠다는 약속 => 자신의 수준을 올리겠다는 약속
- 소프트웨어는 현재 모든 곳에서 사용되고 매우 중요한 일들을 처리, 전문가로서 결국 소프트웨어에 대한 책임은 개발자가 가져야 한다

## 당연한 기대
- 고객이 제품의 퀄리티를 기대하는 것은 당연하다
- 개발자는 기술적으로 준비된 상태를 유지해야 한다 => 배포주기에 따라 항상 기술적으로는 릴리스 할 수 있도록 준비되어야 한다
- 안정적 생산성을 유지해야한다 => 코드 품질 등이 하락하면 생산성이 지속적으로 하락한다
- 낮은 수정 비용을 가져야한다
- 짝 프로그래밍, 테스트 주도 개발, 리팩터링, 단순한 설계를 통하여 지속적인 개선을 해야한다
- QA 는 시스템적인 문제를 찾지 못해야 한다. 만약 찾는다면 개발 프로세스의 문제를 의심해보아야 한다. => QA 는 개발이 끝난 후가 아니라 어떤 자동 테스트를 만들어야 할 지 같이 고민하는 역할이 더 어울린다. 즉, 수동 테스트는 최대한 줄이는 것이 좋다
- 하나의 팀처럼 행동해야 한다
- 정확한 추정을 해야한다 => 아는 것을 토대로 모르는 것을 추정해야 한다
- 진짜 대답이 아니요 일때는 아니요라고 할 수 있어야 한다
- 지속적이고 적극적인 학습을 해야한다
- 서로를 멘토링할 수 있어야 한다

## 권리장전
### 고객 권리 장전
- 전체 계획을 알 권리 : 무엇을, 언제, 얼마의 비용으로 완성할 수 있는 지
- 반복 주기마다 가능한 한 많은 가치를 얻을 권리
- 작동하는 시스템을 통해 진척도를 알 권리 : 개발자는 고객이 제공한 테스트로 계속해서 시스템을 검사하여 동작을 증명
- 과도한 비용 추가 없이 기능이나 우선순위를 바꿀 권리
- 일정이나 추정이 바뀐 경우 제때 알림을 받고, 일정을 맞추기 위한 업무 범위를 조정할 권리, 언제든지 프로젝트를 취소할 권리

### 개발자 권리 장전
- 명확하게 정의된 우선순위와 함께 무엇이 필요한지를 알 권리
- 언제나 높은 품질의 결과물을 만든 권리
- 동료나 관리자, 고객에게 도움을 요청하고 받을 권리
- 자신만의 추정치를 만들고 갱신할 권리
- 담당 업무를 할당받는 게 아니라 수락할 권리

# 비지니스 실천 방법
## 계획 세우기
- 프로그래머는 프로젝트를 매우 작은 조각으로 잘게 자르는 일을 한다 => 코드로 한줄한줄 표현
- 프로젝트 계획을 세울 때는 확실한 시간 범위를 산정하고 이 시간 범위를 가능한 줄이기 위해 약간의(너무 많지 않은) 시간을 투자하는 것이다.
  - 확실하게 끝날 수 있는 시간의 범위를 추정하자는 의미인데, 사실 프로젝트는 유동적으로 변하기 때문에 이 범위도 시간의 흐름에 따라 유동적으로 변한다고 할 수 있다.
- 삼변량 추정(trivariate estimation)
  - 최선, 보통, 최악의 경우의 일정으로 추정하는 방법
  - PERT 기법으로 관리할 수 있다.
  - 정밀도가 낮음
- 스토리 포인트(story point)
  - 특정 스토리마다 포인트를 부여하는 기법
  - 부여된 포인트들은 해결하기 위한 노력의 추정치
  - 특정 스토리를 해결하면 그 스토리에 부여된 포인트에 따라 다른 스토리들도 일정을 추정해 볼 수 있다. => 이것 또한 추정치이기 때문에 틀릴 수 있음, 데이터들을 쌓아감으로써 추정치의 정확도를 올려야함
  - 스토리의 포인트를 부여할 때도 민주적인 방법을 사용하여야 하며, 반복주기의 중간에 해결된 스토리 포인트를 보고 남은 기간동안에 해결할 수 있는 포인트를 예측하여 조절한다. 즉, 반복주기동안에도 유동적으로 계획을 변경한다

### 스토리
- 사용자 스토리는 기능을 기억하기 위해 짧게 설명을 씀
- 세부사항은 추후에 인수테스트로 작성
- 스토리를 쓸때 지켜야할 여섯가지(INVEST)
  - I(독립적인 Independent) : 사용자 스토리는 서로 독립적 => 구현하는 데 순서에 구애받지 않아야 함(실질적으로는 순서에 구애받는 경우가 많으나 최대한 의존성을 줄이자)
  - N(협살할 수 있는 Negotiable) : 개발자와 사업부서가 세부사항을 협상
  - V(가치 있는 Valuable) : 명확하고 계량할 수 있는 비즈니스 가치가 있어야 함
  - E(추정할 수 있는 Estimable) : 개발자가 작업량을 추정할 수 있게 구체적이어야 함
  - S(작은 Small) : 개발자 한두 명이 반복주기 한 번 이내에 구현하기 힘들정도로 크면 안됨
  - T(테스트 할 수 있는 Testable) : 사업 부서가 스토리 완료를 증명하는 테스트를 제시할 수 있어야 함
- 쪼갤 수 없는 스토리는 거의 없음
- 스토리의 크기를 작고 명확하게 유지하는 것이 좋음
- 스파이크 : 메타스토리 => 기간 산정이 힘든 (학습이 필요하다던가 하는) 스토리

### 반복주기 관리
스토리는 반복주기 안에서 완료되는 것이 좋다. 두 개의 스토리를 50% 씩 달성하는 것보다 한개의 스토리를 완성시키는 것이 더 좋다.

### 인수 테스트
- QA 가 인수테스트를 작성하지 않았다면 계획 회의가 끝나자마자 작성해야한다.
- QA 와 개발자가 인수 테스트를 짝프로그래밍으로 만드는 것도 좋다.
- 반복주기의 중반이 되었는데도 인수테스트가 작성되지 않았다면 개발자도 도와야한다.
  - 이런일이 자주 발생한다면 QA 와 개발자의 비율이 맞지 않는 지 고민해봐야함
- 반복주기가 종료되기 전에 인수테스트 작성이 끝났다면 다음 주기에 실행할 인수테스트를 미리 추정하여 작성한다.
  - 불확실하더라도 미리 작성해 두는 것이 좋음
- 개발자와 QA 는 인수 테스트를 작성하며 지속적인 커뮤니케이션을 해야한다.

### 속도
- 반복주기에서 업무 처리 속도가 떨어진다는 것은 코드 품질에 문제가 있을 가능성이 큼
  - 리팩터링이 충분하지 않을 가능성을 고려
    - 테스트코드가 적어서 리팩터링이 두려울 수 있다
- 속도가 오른다면 관리자의 압박에 개발자들이 스토리의 포인트를 높게 산정하는 것일 수 있다
- 속도가 느리거나 빠르다고 반복주기가 실패한 것이 아니라 반복주기에서 데이터를 획득하지 못하는 것이 실패하는 것이다.
- 반복주기가 여러회 반복되다보면 속도의 기울기는 0에 가까워져야한다.

> 기준스토리와 지속적으로 비교하며 스토리 인플레이션이 발생하지 않도록 주의해야한다.

## 작은 릴리스
- 개발팀이 소프트웨어를 자주 릴리스 해야 함
  - 기술적으로 릴리스가 자주 일어나야하고, 실제로 반영하는 것은 사업상의 결정
  - 지속적 배포(Continuous Delivery)를 짧은 주기로 해야함

## 인수 테스트
- 사업부서가 요구사항을 명시해야 함
- BDD(Behavior-Driven Development) 기반으로 작성하면 좋음
- 업무분석가와 QA가 작성
- 인수테스트로 반복주기의 스토리 완료 여부 판명
- QA 의 업무가 프로젝트의 종료단계가 아닌 시작단계에서 실행되게 됨
- 지속적인 빌드(continuous Build)를 통해 자동화된 테스트를 지속적으로 실행

## 전체팀
- 고객(제품책임자 Product Owner)과 개발팀이 하나의 팀으로서 가까이에서 지속적으로 의견을 주고받으며 일하는 것이 이상적이다.

# 팀 실천 방법
## 메타포
어떠한 개념에 대한 용어의 정의를 말하는 데, 이러한 용어는 모두 이해하기 쉬워야 한다. 모든 사람이 동의하는 언어로 표현되어야 하고 DDD 에서는 이것을 유비쿼터스 언어라고 부른다(Ubiquitous Language)

## 지속 가능한 속도
프로젝트는 지속 가능한 속도로 진행해야한다. 근무 시간을 과도하게 초과하여 휴식을 충분히 취하지 못하면 집중력이 저하되고 오히려 생산성이 떨어진다. 흔히들 SI 의 가장 큰 문제점이라고들 말하는 보여주기식 야근 문화를 생각해보면 지속 가능한 속도를 유지하는 것이 얼마나 중요한 일인지 알 수 있다.

## 공동 소유
누군가 코드를 소유하고 공유하지 않으면 암묵적인 계급 체계가 생길 수 있다. 이것은 특정 계층이 많은 권리를 갖고 서로간의 불신을 만든다. 코드와 정보는 모두가 공유해아하고 투명해야한다. 전 직장에서 근무할 때 가장 문제라고 여겼던 것이 정보의 독점화였다.(PM이 정보를 매우 한정적으로만 공유)

## 지속적 통합
지속적인 통합을 위해 브랜치로 머지시키는 작업을 꾸준히 자주 일어나야한다. 이를 통해 지속적인 빌드를 수행(젠킨스등의 도구 사용)해야 하며 빌드가 자주 일어나면 테스트가 자주 수행되고 빌드가 깨지는 지 확인하기 쉽다. 이 때 빌드 수행을 위해 실패하는 테스트를 억지로 무시하는 것은 재앙을 불러 올 수 있다.

## 스탠드업 미팅
스탠드업 미팅은 몇가지 원칙을 지켜야한다.
- 미팅 참석은 필수가 아님
- 매일 할 필요없이 일정에 맞게 잡는다
- 10분안으로 무조건 끝낸다. 팀의 규모에 상관없이
- 회의 진행 방식은 단순하게 3가지 질문과 답만 한다(간단하게)
  1. 지난 스탠드업 미팅 이후 한일
  2. 다음 스탠드업 미팅까지 할일
  3. 어떤 장애물이 있는지
- 스탠드업 미팅은 개발자만 말해야한다.(다른 직군도 참여는 가능하지만 대화에 끼어들어서는 안됨)