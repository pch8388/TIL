# 서문
- 수많은 관심사로부터 도메인 설계를 격리하면 모델과 설계의 관계가 훨씬 분명해짐

# 04. 도메인 격리
## LAYERED ARCHITECTURE(계층형 아키텍처)
- 사용자 인터페이스 - 응용 - 도메인 - 인프라스트럭처
- 관심사의 분리(separation of concern) 필요
- 계층화의 핵심 원칙은 한 계층의 모든 요소는 오직 같은 계층에 존재하는 다른 요소나 계층상 아래에 위치한 요소에만 의존
  - 단방향으로만 의존
  - 응집력 있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전
  - 상위 계층과의 결합을 느슨하게 유지

### 계층 간 관계설정
- 분리의 이점을 잃지 않으면서 각 계층을 서로 연결하는 것이야말로 각종 패턴이 존재하는 이유
- 각 계층은 설걔 의존성을 오직 한 방향으로만 둬서 느슨하게 결합
- 하위 수준의 객체가 상위 수준의 객체와 소통해야 할 경우에는 콜백(call back)이나 OBSERVER(관찰자) 패턴처럼 계층 간에 관계를 맺어주는 아키텍처 패턴을 활용
- 분리의 주된 이점은 애플리케이션 계층이 단순해저서 애플리케이션 본연의 책임에만 집중
  - 메시지를 언제 보내는지는 알아도 어떻게 보내는지 알필요 없어짐
- 응용 계층과 도메인 계층에서는 인프라스트럭처 걔층에서 제공하는 SERVICE 를 요청

### 아키텍처 프레임워크
- 가장 바람직한 아키텍처 프레임워크라면 도메인 개발자가 모델을 표현하는 것에만 집중하게 해서 복잡한 기술적 난제 해결

### 도메인 계층
- MODEL-DRIVEN DESIGN 에서는 도메인 계층의 소프트웨어 구성물이 모델의 개념을 반영
- 도메인 주도 설계의 전제 조건은 도메인 구현의 격리

## SMART UI(지능형 UI) : 안티패턴
- 단점
  - 데이터베이스를 이용하는 방식 말고는 여러 애플리케이션을 통합하기가 수월하지 않음
  - 행위를 재사용하지 않으며 업무 문제에 대한 추상화가 이루어지지 않음
  - 추상화의 부재로 리팩토링 여지가 제한
  - 복잡성에 금방 압도되어 애플리케이션의 성장 경로가 순전히 부가적인 단순 응용으로만 향함
- 단지 다루기 쉬운 언어를 사용한다고 해서 다루기 쉬운 시스템이 만들어지는 것은 아니며, 오히려 비용이 많이 들 수 있음
- 단순한 기능부터 시작해서 계속적인 반복주기를 토대로 개발 진행
- 아키텍처에서 응집력 있는 도메인 설계가 시스템의 다른 부분과 느슨하게 결합될 수 있게 도메인 관련 코드를 격리한다면 도메인 주도 설계를 지원할 수 있을 것
  - 레거시를 리팩토링 할 때 이러한 점을 고려하여 리팩토링을 진행하면 도메인 주도 설계가 추구하는 방향으로 가능할 것 같다

# 05. 소프트웨어에서 표현되는 모델
- 모델을 표현하는 세 가지 패턴 : ENTITY, VALUE OBJECT, SERVICE
- 객체보다는 행동이나 연산으로 좀 더 명확하게 표현되는 것은 SERVICE 로 표현하는 것이 더 나을 때가 있다

## 연관관계
- 가능한 관계를 제약하는 것이 중요
- 연관관계를 좀 더 쉽게 다루는 방법
  1. 탐색 방향 부여
  2. 한정자를 추가해서 사실상 다중성을 줄임
  3. 중요하지 않은 연관관계 제거
- 도메인의 특성이 반영되게끔 연관관계를 일관되게 제약하면 연관관계의 의사전달력이 풍부해지고 구현이 단순해지며, 나머지 양방향 연관관계도 의미를 지니게 됨

## ENTITY
- 개념적 식별성은 객체와 해당 객체의 저장 형태, 현실의 행위자의 구현 사이에서 일치해야 함
- ENTITY 의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성
  - 추상적인 연속성은 여러 형태를 거쳐 전달
- 어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 ENTITY 라고 함
  - 연속성을 유지해야 함
  - 식별성이 정의되어야 함
  - 정체성에 초점을 맞춰야 함
  - 의미에 따라 ENTITY 를 분류한다면 모델이 더욱 투명해지고 구현은 견고해짐
- ENTITY 는 클래스 정의를 단순하게 하고 생명주기의 연속성과 식별성에 집중
- 객체가 동일하다는 것이 어떤 의미인지 해당 모델 안에서 정의해야하고, 그로 인해 해당 객체가 ENTITY 가 될 지 VALUE OBJECT 될 지 결정할 수 있다
  - 모델 내의 모든 객체가 의미 있는 식별성을 지닌 것은 아님 (ENTITY인 것은 아님)
  - 한 객체가 속성보다는 식별성으로 구분될 경우 모델내에서 이를 해당 객체의 주된 정의로 삼아라  
  - 현실세계의 같은 사물이라도 상황에 따라 도메인 모델에서 ENTITY 일수도 VALUE OBJECT 일수도 있음

### ENTITY 모델링
- ENTITY 객체의 가장 본질적인 특징만으로 정의
- 개념에 필수적인 행위만 추가 => 행위에 필요한 속성만 추가
  - 행위를 먼저 정의하고 행위에 필요한 속성만 추가한다
  - 오브젝트(조영호 저)에서 나왔듯이 객체는 행위가 중요하다
  - 하지만 객체의 책임과 역할에 따라 행위를 먼저 정의한다는 것은 대단히 힘든일이다
- ENTITY 는 주로 자신이 소유한 객체의 연산을 조율해서 책임을 완수

## VALUE OBJECT
- 개념적 식별성이 없는 객체이지만, 사물의 어떤 특징을 묘사할 수 있는 객체
  - 개념적 식별성을 갖지 않으면서 도메인의 서술적 측면을 나타냄
  - 어떤 특징에 좀 더 뚜렷한 의미를 부여하고 싶을 때 쓰는 것이라고 생각한다
  - 그러한 특징을 나타내는 객체는 단위가 작을 수록 좋지만, 복잡도가 너무 상승할 수 있다
  - Integer, String 등의 클래스가 VALUE OBJECT 의 가장 좋은 예라고 생각된다
- 특별하게 다루어야 할 부분과 그렇지 않은 부분을 구분
- VALUE OBJECT 는 설계요소를 표현할 목적으로 인스턴스화 되는 데, 우리는 이러한 설계 요소가 어느 것인지 보다 무엇인지에 관심이 있다
- VALUE OBJECT 특징
  - 복잡한 연산을 가지고 있을 수도 있음
  - 여러 객체의 조합일 수 있음
  - ENTITY 를 참조할 수 도 있음
  - 일시적인 용도로 사용되기도 함
  - ENTITY 나 VALUE OBJECT 의 속성으로 사용될 수 있음
  - 불변적으로 다루는 것이 좋음
  - 식별성을 부여하지 않아야 함
- VALUE OBJECT 를 정의하여 ENTITY 를 유지하는 데 필요한 설계상의 복잡성을 피할 수 있음
- VALUE OBJECT 를 구현하는 속성은 개념적 완전성(conceptual whole)을 형성해야 함

### VALUE OBJECT 의 설계
- 객체의 소유자가 제어하지 못하는 떠돌이 객체에서는 무슨 일이 일어날지 알수 없음
- VALUE 는 소유자의 불변식(invariant)을 위반해 소유자가 손상되게끔 변경될 수 있음
- VALUE OBJECT 는 많아지는 경향이 있으므로 성능 최적화를 위해 별도의 대안을 마련해야 할 수 있음
  - FLYWEIGHT 등의 패턴 사용
  - 복사와 공유 중 어느 것이 효율적일 지는 구현 환경에 따라 다름
  - 복사는 객체의 개수가 굉장히 많아짐
  - 공유는 분산 시스템에서는 느려질 수 있음
  - 공유가 좋은 경우
    - 공간을 절약하거나 데이터베이스 내의 객체 수를 줄이는 것이 중요한 경우
    - 통신부하가 낮은 경우(중앙집중형 서버같은 경우)
    - 공유 객체의 불변성이 엄격하게 지켜지는 경우
- 성능 문제로 VALUE OBJECT 속성 값의 변경을 허용하는 경우
  - VALUE 가 자주 변경되는 경우
  - 객체 생성이나 삭제에 비용이 많이 드는 경우
  - 교체로 인해 클러스터링이 제한되는 경우
  - VALUE 를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경우

### VALUE OBJECT 를 포함한 연관관계 설계
- 모델에 포함된 연관관계의 수가 적고 연관관계가 단순할수록 더 나은 모델
- VALUE OBJECT 간의 양방향 연관관계는 완전히 제거하도록 노력해야 함 => 아무 의미가 없음
  - 그래도 필요하다고 여겨진다면 그 객체에 아직 파악하지 못한 식별성이 있는 건 아닌지 고민해봐야 한다

