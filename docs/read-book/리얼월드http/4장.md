# 4장. HTTP/1.1의 신택스: 고속화와 안전성을 추구한 확장
## 통신고속화
### Keep-Alive
- TCP/IP 통신의 효율화 => 연속된 요청에는 통신을 닫지 않고 재이용
- 요청헤더 <-> 응답헤더 같음   
  ```Connection: Keep-Alive ```
- HTTP/1.1 에서는 기본적으로 동작
- RTT(round-trip time) : 패킷이 1회 왕복하는 시간
- TLS 핸드셰이크 2RTT
  - Keep-Alive 가 핸드셰이크 횟수를 줄임 => 인증을 할 필요가 줄어들기 때문
- 클라이언트나 서버가 Connection: Close 를 헤더에 부여할 때까지 유지
- HTTP/2 에서는 무시됨 => 연결관리는 다른 메커니즘으로 내부적으로 처리
### 파이프라이닝
- Keep-Alive 사용 전제
- 최초요청 완료전 다음 요청을 보냄
- 기본으로 활성화 된 브라우저가 적음
- HOL 블로킹(head-of-line blocking) 문제
  - 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
- HTTP/2 에서 스트림의 근간이 되는 기술

## TLS(전송계층 보안)
- https 스키마 => 안전한 통신, 433 기본포트
- SSL 3.0 바탕
- 일반포트로 시작했다가 TLS 화 하는 방법도 있음
  - StartTLS, Opportunistic TLS
- 기본프로토콜을 TLS 로 업그레이드 하기도 함 : SMTP(25) => SMTPS(465)
### 해시함수
- 수학적 특징
  1. 같은 알고리즘 + 데이터면 항상 값이 같음 (H(A) = X)
  2. 알고리즘 길이가 같으면 해시값 길이 고정 (SHA-256 => 256비트 고정)
  3. 해시 값에서 원본 데이터 유추 힘듬(약한 충돌 내성)
  4. 가틍ㄴ 해시 값을 생성하는 다른 데이터를 찾기 힘듬(강한 충돌 내성)
- 공통키 암호, 공개키 암호, 디지털 서명
  - 공통키 : 대칭키 => 암복호화를 같은 키로 함
    - TLS 의 일반통신 암호화
  - 공개키 : 비대칭키 => 공개키, 비밀키
  - 디지털 서명 : 공개키 응용
    - 본문 해시화 후 암호화
- 키교환 : 클라이언트 <-> 서버간의 키교환
- TLS 는 공통키 + 공개키
  - 통신마다 한번만 사용하는 공통키 생성 -> 공개키 방식으로 상대에게 전달 -> 공통키를 이용해서 빠른 통신
  - 공개키 방식이 더 안전하지만 속도가 느림
  - 공통키(AES), 공개키(RSA)
### TLS 통신 절차
1. 핸드셰이크로 통신확립
2. 레코드 프로토콜
3. SessionTicket 구조를 이용한 재접속시 고속 핸드셰이크
- 서버의 신뢰성 확인
  - 공개키 기반구조 (Public Key Infrastructure) : PKI
  - 서버 -> 클라이언트 SSL 인증서 획득 => 인증서 : X.509 형식
    - CA(인증기관) : 인증서 발행자 => 신뢰성 확인의 핵심
    - 인증서에는 발행자의 디지털 서명이 있음
- 키 교환과 통신의 시작
  - 키 교환
    - 인증기관 -> 서버로 인증서 발행 -> 클라이언트로 인증서 전달 -> 인증기관에게 인증서의 신뢰성 확인 -> 클라이언트는 공통키 작성하고 인증서 내의 공개키로 암호화 -> 서버로 키 전송 -> 서버는 암호화된 키를 복호화 -> 통신
  - 키 교환 전용 알고리즘
    - 키를 생성할 시드를 클라이언트, 서버 양쪽에 하나씩 만들어 계산하며 교환
    - 키가 동적으로 계산되고 파일로 저장되지 않아 유출 가능성이 낮음
  - 통신
    - 공통키 암호방식을 이용
    - TLS 1.2 이전 : 통신 내용의 해시값 계산 -> 공통키 암호로 암호화
    - TLS 1.3 이후 : AES + GCM, AES + CCM, ChaCha20-Poly1305 등의 암호화
- 통신의 고속화
  - 일반적 접속
    - TCP/IP 단계 1.5RTT -> TLS 핸드셰이크 2RTT -> HTTP 요청 1RTT
    - TCP/IP 의 마지막 0.5 와 TLS 최초통신이 함께 이루어지므로 4RTT
    - TLS 미사용시 2RTT
    - Keep-Alive 를 이용하여 최초 통신 이후로는 1RTT
  - TLS1.2 : 세션 재개 기능(session resumption) => 최초 핸드셰이크 전에 사용하던 세션 ID(32비트)를 보내면 이후 키 교환 생략 => 1RTT 로 세션 재개
  - TLS1.3 : 사전에 키를 공유 => 0RTT 로 최초 요청부터 정보전송 
    - 키 교환과 비밀키 암호가 분리
    - 최초의 Client Hello 로 클라이언트 쪽에서 키 교환 가능
      - 통신이 1RTT 감소 => 인증 1RTT 완료
  - QUIC : 핸드셰이크가 필요없는 UDP 사용

> HTTP/1.1 : 2~6개 TCP 세션 병렬화
> HTTP/2 : 하나의 TCP 세션 다중화

### 암호 스위트
- 키 교환 방법, 메시지 암호화, 메시지 서명방식 등에서 각각 사용하는 알고리즘 조합을 리스트화해서 관리
  - 확인 방법  
  ```openssl ciphers -v```

### 프로토콜 선택
- TLS 제공 기능으로 애플리케이션 계층 프로토콜 선택
- ALPN : TLS 최초 핸드셰이크 시 클라이언트가 서버에 클라이언트가 이용할 수 있는 프로토콜을 보냄
  -> 서버가 응답으로 키교환 및 인증서와 선택한 프로토콜을 보냄

> TLS 는 통신경로를 보호하는 것, 클라이언트와 서버가 서로 신뢰가능한지에 대한 보장을 하지 않음

## 프로토콜 업그레이드
- 클라이언트나 서버에서 요청 가능
- 업그레이드 종류
  1. HTTP -> TLS/1.0, TLS/1.1, TLS/1.2
  2. HTTP -> websocket
  3. HTTP -> HTTP/2(h2c)
- HTTP/2 에서는 삭제 => TLS 의 ALPN 권장 => 웹소켓 용으로 거의 쓰임
- 문제점
  - 프록시의 정보탈취 가능성
  - 중간자 공격에 취약
- HTTP -> HTTPS 업그레이드 시 301 Redirect 권장

## 가상호스트 지원
- 가상 호스트를 이용하여 하나의 웹서버로 여러 웹 서비스 운영(ex: 아파치 버추얼 호스트)

## 청크
- 전송을 나누어 할 수 있음
- Transfer-Encoding: chunked
  => Content-Length 를 포함할 수 없음
- 업로드, 다운로드 가능하지만 브라우저에서 업로드를 지원하지 않음

## 바디전송확인
- 클라이언트 -> 서버로 데이터를 받을 수 있는 지 확인
  - Expect : 100-continue  요청헤더 => Content-Length 같이 보냄
  - 100 Continue : 가능
  - 417 Expactation Failed : 불가능