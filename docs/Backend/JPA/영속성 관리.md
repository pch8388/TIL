# 영속성 관리
## EntityManagerFactory
- DB 하나당 하나가 생성된다고 생각하면 됨
- EntityManager 를 생성
- Thread safe

## EntityManager
- Transaction 당 하나 생성한다고 생각하면 됨
- Trread safe 하지 않음

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- EntityManager 를 이용하여 영속성 컨텍스트에 접근

### Entity lifecycle
1. 비영속 : 영속성 컨텍스트와 관계 없는 상태
2. 영속 : 영속성 컨텍스트에 저장된 상태 (persist, merge, find)
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태 (detach, clear, close)
4. 삭제 : 삭제된 상태(remove)

### 장점
- 1차캐시
- 동일성 보장 (같은 엔티티면 같은 주소의 레퍼런스)
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### flush
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영
- 호출하는 방법
  1. flush() 직접호출
  2. 트랜잭션 커밋시 자동호출
  3. JPQL 쿼리 실행시 자동호출
    - JPQL 쿼리는 데이터베이스에 직접 쿼리를 실행하기 때문에 플러시 되지 않으면 영속성 컨텍스트의 내용이 적용되지 않은 채 조회하게 됨 

## 준영속 상태
- 영속 상태의 엔티티가 영속성 컨텍스트에서 detached(분리)된 것
- 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능 사용 불가
- 영속 → 준영속 만드는 방법
    1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
    2. em.clear() : 영속성 컨텍스트 초기화
    3. em.close() : 영속성 컨텍스트 종료
- 특징
    1. 비영속 상태에 가까움
    2. 식별자 값을 가지고 있음 : 비영속 상태는 식별자 값이 없을 수도 있지만 준영속에서는 영속상태에서 변화된 거라 반드시 식별자 값이 있다.
    3. 지연 로딩 불가 : lazy loading(지연 로딩)은 실제 객체 대신 프록시 객체를 로딩 해두고 실제 사용 시 영속성 컨텍스트를 통해 데이터를 불러오는 방법
- merge(병합) : 준영속 → 영속  ⇒ 새로운 영속상태의 엔티티를 반환