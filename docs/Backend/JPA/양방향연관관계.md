# 양방향 연관관계
- 양방향 연관관계는 편의상 붙이는 이름이고 사실은 단방향 연관관계 2개
- 관계형 데이터베이스는 관계에 대한 방향성이 없음
  - join 같은 집합연산으로 조회를 함
- 객체는 항상 방향성이 있어야 하기 때문에 단방향 연관관계 2개로 양쪽 모두에서 접근하도록 해줌

## 연관관계의 주인
- 양방향 연관관계는 연관관계의 주인을 지정해야 함
- 둘 중 어느 객체가 fk 값이 변했을때 데이터베이스의 값을 update 할 지 결정해야 하기 때문
- 연관관계의 주인은 비즈니스 적으로 더 중요한 객체가 아닌 fk 를 가져야 하는 객체로 하는 것이 좋음
  - 실제로 update 의 대상이기 때문에
- 연관관계의 주인이 아닌 클래스는 주인인 클래서의 필드를 mappedBy 로 지정해야 함

```java
@Entity
public class Member {
  @Id @GeneratedValue
  private Long id;
  
  @ManytoOne
  @JoinColumn(name = "team_id")   // team_id 를 fk 로 갖는다
  private Team team;
}

@Entity
public class Team {
  @Id @GeneratedValue
  private Long id;
  
  // team 1 : member n 이기 때문에 n 쪽에 fk 가 생기고, 연관관계의 주인의 필드인 team 에 mapping 한다
  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<>();
}
```

### 주의점
- 두 객체 모두가 서로를 참조하기 때문에 오는 문제점들이 몇가지 있음
  1. 연관관계의 주인의 데이터가 변경되어야 DB에 적용됨
    - 실제로는 연관관계의 주인 (fk 키를 가진 테이블) 이 데이터가 변경되면 업데이트 쿼리가 나가고, 주인이 아닌 엔티티가 업데이트 된 것은 무시됨
  2. 1 의 이유로 연관관계의 주인에게만 값을 입력하여도 사실 DB 데이터상은 문제가 없지만, 객체의 관점에서 보았을 때는 올바르지 않음
    - 두 군데 모두 올바른 참조가 되어야 서로 참조하는 의미가 생김
    - 값이 모두 세팅되지 않은 상태에서 DB 에 업데이트를 하지 않은 같은 트랜잭션에서 값을 가져올 경우 값이 없을 수 있음
      - 영속성 컨텍스트에는 세팅되지 않은 상태의 값이 들어가 있고, 실제 DB에 데이터를 넣고, 영속성 컨텍스트를 비우고 조회하지 않으면 계속 값을 세팅하지 않은 객체가 반환됨
    - 영속 계층에 독립적으로 테스트코드를 작성하고 싶을 때도 방해가 됨
  3. toString, equals 등의 메서드를 함부로 재정의 하면 순환참조가 발생하여 stack over flow 를 맞게 될 수 있음

### 연관관계 편의 메서드
- 연관관계가 변경되면 상대 객체도 업데이트를 해주어서 객체간의 불일치를 해결한다

```java
@Entity
class Member {
  public void changeTeam(Team team) {
    this.team = team;
    // team 쪽에도 변경사항을 적용시킴
    team.getMembers().add(this);
  }
}
```

### 정리
- 양방향 연관관계로 인해 얻을 수 있는 설계상의 이점은 처음엔 별로 없음
- 처음엔 단방향으로 모두 설계하고, 후에 필요할 때마다 양방향 연관관계를 추가하더라도 리소스가 많이 소모되지 않음
  - java 코드 몇줄만 수정하면 됨 => DB 에는 변화가 없음
- 양방향 연관관계의 주인은 fk 키를 가져야 하는 엔티티로 
