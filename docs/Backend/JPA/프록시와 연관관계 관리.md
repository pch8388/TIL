# 프록시
- JPA 구현체인 하이버네이트는 지연로딩을 구현하기 위해 프록시를 사오ㅛㅇ하는 방법과 바이트코드를 수정하는 두가지 방법을 제공

[바이트코드 수정 설정](http://devdoc.net/javaweb/hibernate/Hibernate-5.1.0/userGuide/en-US/html/ch03.html)

- 프록시는 실제 객체를 사용하지 않고, 가상의 객체를 이용해 로직의 흐름을 제어하는 디자인 패턴
- 비용이 많이 드는 연산 등을 실제로 필요한 시점에 수행하도록 할 수 있음
- JPA 에서는 데이터베이스에 실제 접근이 필요한 순간에 접급하도록 프록시 패턴을 사용
  - Entity 를 상속한 프록시 객체를 하이버네이트가 생성하기 때문에, Entity 의 기본 생성자는 항상 protected 이상의 가시성을 지녀야 한다

## 프록시 기초
- em.find() : 데이터베이스를 통해 실제 엔티티 객체 조회
- em.getReference() : 프록시 객체 조회
  - 일단 프록시 객체를 반환하고, 실제로 엔티티의 데이터가 필요한 상황이 오면 영속성 컨텍스트에 초기화(실제 엔티티 생성을 요청)를 요청한다 -> 데이터베이스 조회
- 타입체크를 할 경우 프록시 객체와 엔티티 객체는 정확한 타입은 다르기 때문에 주의해야함
- 영속성 컨텍스트에 찾으려는 엔티티가 이미 있으면 em.getReference 를 호출해도 해당 엔티티를 반환
- JPA는 같은 엔티티를 조회할 때는 항상 같은 참조를 반환하는 것을 보장하기 위해 해당 엔티티가 프록시 객체로 참조되어있으면, em.find 로 조회해도 프록시 객체로 반환한다(반대의 경우도 마찬가지)
- 준영속 상태의 프록시를 초기화하면 예외가 발생
  - JPA는 트랜잭션 내에서만 영속성 컨텍스트를 유지하기 때문에, Spring 에서 layer 간에 지연로딩이 걸린 엔티티를 넘기면 문제가 발생할 수 있다 => 아직 데이터가 없는 프록시 객체인데, 해당 엔티티의 값을 쓰는 행위를 하면 영속성 컨텍스트를 쓸 수 없기 때문
