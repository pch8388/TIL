# 피드백
- @OrderColumn : JPA 에서 순서 index 를 저장하는 컬럼을 추가해줘서 순서를 보장하도록 한다
- 패키지 의존성 제거 : 양방향 의존에서 단방향 의존으로 바꾸기
- DIP 에서 말하는 유연성이 극대화된 시스템 ⇒ 추상에 의존하며 구체에 의존하지 않는 시스템
- UserDetails 에 과연 getAge 등이 필요할까? ⇒ 세부적인 정보를 갖지 않고, 인증에 필요한 정보만 드러내는 것이 좋은 설계

## 객체 참조
- 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라 ⇒ 라이프사이클에 따라 묶어라
    - 라이프사이클이 다르다면 아이디를 통해 약한 결합을 통해 의존성을 끊어내는 것도 좋다
- 도메인 제약사항을 공유하는 객체들을 함께 묶어라
- 가능하면 분리하라

## 테스트하기 어려운 코드
[오키콘의 정진욱님의 세미나 참조](https://youtu.be/Cz_a2gQp63c)

- 외부상태를 변경하는 코드
- 항상 같지 않은 결과를 반환하는 코드
- 테스트하기 쉬운 코드로 바꾸기
    - 테스트하기 쉬운 코드와 어려운 코드를 분리
    - 두 부류의 코드의 접점을 최대한 바깥으로 보낸다
    - 어려운 부분을 객체로 분리하여 컴포지션해서 사용할 수 있도록 한다
    - 테스트하기 어려운 부분을 검증하지 않는다 ⇒ 전체적인 기능은 인수테스트로 검증한다

### @Mock vs @MockBean
- Mock : 순수 객체를 가짜객체로 만듬
- MockBean : 컨테이너에 담겨 있는 대상을 가짜객체로 만듬
- 둘의 차이는 스프링 컨텍스트 환경에서 테스트 할 것인가 아닌가

# 문서자동화
## ATDD + 문서자동화
- 인수테스트에 문서를 같이 만들어 주면 더 깊은 이해를 할 수 있다
- 개발 전 문서화 장점
    - 병렬 작업이 가능
    - 특히 백엔드 & 프론트엔드 병렬 작업 시 유용함
        - 커뮤니케이션 비용을 줄일 수 있음
        - 동작하는 Mock API 생성
- 문서 자동화란?
    - 문서를 기능과 동기화를 맞추기 어려움
    - 이를 해결하기 위해 코드에서 관리
- Swagger
    - API call 하여 테스트하는 기능에 특화
    - 기능이 많음
    - 불필요한 프로덕션 코드 오염
- Spring Rest Docs
    - 테스트 코드 기반으로 작성하여 프로덕션 코드에 영향이 적음
    - 작성하기가 비교적 어려움
    - 테스트가 되지 않으면 문서화가 되지 않음
    - api call 기능은 intellij 의 http request 기능을 사용하여 대체
    - Asciidoctor : rest docs 가 만든 스니핏을 html 형태의 문서로 만들어 낸다
    - 테스트를 실행하면 build/generated-snippets 아래에 스니핏이 생성된다
    - 문서 템플릿 파일 작성
        - Asciidoc Syntax 에 따라 뼈대 문서를 작성
    - asciidoctor task 실행하면 html 문서가 생성됨

### Cycle
인수테스트 정의 → 인수테스트 작성 → mock server dto 작성 → 문서화 → 구현

### 개발순서
1. 인수 테스트 만들기
2. 컨트롤러 (응답하는 부분) 만들기
3. 응답값이 있는 경우 응답값 생성 로직을 서비스로 위임하기
4. 위임한 부분에 대한 스터빙하고 문서화 테스트 만들기


[4주차 미션완료](https://github.com/next-step/atdd-subway-fare/tree/pch8388)