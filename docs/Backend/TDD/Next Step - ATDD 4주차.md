# 2주차 피드백
- 테스트만을 위한 프로덕션 코드는 지양하지만 과하게 사용되는 것이 아니라면 제한적으로 허용할 수 있음

## 인수 테스트에 대해
- 응답코드만으로 검증 가능?
- 실제로 데이터가 저장되었는지에 대한 검증이 필요하지 않나?
    - 204와 같은 응답일 경우 진짜 지워졌는지? 이런 검증이 필요하지 않나
- 예외처리를 할때는 의도된 상황에서 실패를 하는 지 하나의 인수테스트 시나리오 안에서 성공과 실패를 모두 검증해야 한다
    - 다른 인수테스트에서 성공하는 시나리오를 이미 테스트 했지만, 실패 테스트가 정확히 의도한 상황에서 발생했는지 확인할 수 있다 ⇒ 모든 경우에 적용되지 않을 수 있다. 도메인의 상황에 따라 방법을 달리해야 한다
- 사용자 관점의 기능과 플로우 검증 : Journey Test or Story Test
    - 하나의 기능이 아닌 흐름에 따라 검증하는 테스트
    - 인수 테스트의 통합을 통해 검증을 하자
    - 정말 필요한 부분에 대해서만 하는 것이 좋다 ⇒ 유지보수가 힘들고 리소스가 많이 든다

### 인수 테스트 통합 시 장점
- 테스트 비용 절감
- 인수 테스트 스텝의 중복을 효과적으로 제거할 수 있음
- 흐름을 검증하면서 자연스럽게 사용자 스토리에 대한 검증이 가능
- 사이드 케이스는 단위 테스트에서 수행하게 유도

### 통합 방법
1. 따로 만든 다음 하나로 통합
2. 처음부터 하나의 테스트 메서드로 기능을 하나씩 검증하며 구현

# 레거시 리팩터링
- 인수테스트를 먼저 만들고 시작
- 세부 구현에 의존하지 않는 블랙박스 테스트이기 때문에 구현이 바뀌어도 인수테스트가 깨지지 않음

### 인수 테스트 작성 후
1. 단위 테스트 작성
2. 구현
3. 단위 테스트 리팩토링
4. 반복

### 기존 코드를 바로 수정하면?
변경한 부분을 의존하는 부분 모두 컴파일 에러 + 기존 테스트 모두 실패

### 안전한 리팩터링 과정
1. 구조설계
2. 새로운 테스트 만들기
    - 기존 테스트는 두고 일단 새로운 인수 테스트를 만든다
3. 기능 구현하기
    - 기존 코드와 중복이 발생할 수 있음
    - 기존 코드와 신규 코드가 함께 존재함
    - 작업 중 다른 작업을 하더라도 문제가 없음
        - 기존 코드가 유지되어 기능에 이슈가 없고, 신규 작업한 코드도 그대로 남아있음
    - 단, 기존 코드와 신규 코드가 혼재되는 기간을 짧게 가져가도록 해야함
4. 반복
    - 기존 코드를 대체할 수 있을 때 대체
    - 기존 프로덕트 코드와 테스트 코드 제거

# 인증 테스트 인증 도구
### RequestSpecification.auth()
- RestAssured 의 auth 이용
- form 인증의 경우 : 요청이 두번나감 ⇒ 인증 + 실제 요청
- basic 인증의 경우 : preemptive 라는 메서드를 통해 요청 한번에 할 수 있게 됨(401 응답을 받고 다시 보내지 않도록)
- oauth2 인증의 경우 : 토큰 생성 요청 → 실제 요청


[3주차 미션완료](https://github.com/next-step/atdd-subway-favorite/tree/pch8388)