# 도메인 주도 개발
- 도메인 : 소프트웨어로 해결하고자 하는 문제 영역. 즉, 업무를 영역짓는 것
- 도메인 모델 : 도메인을 소프트웨어로 표현하기 위해 모델링
  - 소프트웨어 개발자가 해당 도메인에 대해 처음부터 완벽하게 이해하고 구현하기 힘듬
  - 순수하게 도메인에 대해 모델링 하는 개념적인 도메인 모델을 실제 구현에 모두 반영할 수 없음
  - 기술과의 융합이나 구현상의 이점등을 고려하여 개념모델에 가깝게 구현모델을 가져가야 함

## 도메인 모델 패턴
- 일반적인 애플리케이션은 4계층의 아키텍처로 구성
  1. Presentation layer : 클라이언트와의 인터렉션
  2. Application layer : 클라이언트 요청 기능 실행, 도메인 모델을 조합하여 사용, 외부 라이브러리 등의 도메인 외적인 기능들을 이 계층에서 사용함
  3. Domain layer : 도메인 기능을 실행할 계층
  4. Infrastructure : 외부 시스템과의 연동, DB 나 메시징 시스템 등등
- 각 계층은 하위 계층으로만 의존해야 함(상위 계층일수록 클라이언트와 가까움)
> 여기서 클라이언트라 함은 꼭 사용자만을 이야기하는 것이 아니라, http 를 포함한 모든 외부 요청을 말함
- 히자만, 구현을 하다보면 하위계층에 대한 의존성이 생기기 쉬움.
  - 예를 들어, 스프링으로 개발을 하다보면 service 계층에서 persistence 계층의 기술인 특정 데이터베이스 기술에 의존하는 경우가 많음(사실 영속성을 관계형 데이터베이스로 가져간다라고 규정하는 것 자체가 의존하는 것이다)
  - DIP (Dependency Inversion Principle) : 저수준 모듈이 아닌 고수준 모듈에 의존하도록 함으로써 이를 해결
  - service -> repository(interface) 를 의존시키고, 구체화된 기술은 repository interface 를 구현하도록 하여 해결

## 도메인 모델링
1. 요구사항 정리
  - 요구사항을 원하는 형태로 정리
  - 문장이나 순서도, 워크플로우 등을 이용
2. 요구사항에 따른 모델을 정의
  - 추상적으로 이름만 정할수도 있고, 좀 더 구체화 할 수도 있음
  
### Entity
- 엔티티는 식별자를 갖는다는 점에서 value 와 차이가 있음

### Value
- 엔티티가 가질 수 있는 값의 의미를 좀 더 잘 드러내고자 할 때 사용가능 (도메인 개념을 나타낼 수 있음)
- 불변 객체로 사용해야 함
- 밸류 타입을 위한 기능 추가 가능(ex. Money 객체라면 돈에 관련된 계산 로직을 넣을 수 있음)

### 도메인 용어
- 도메인 용어는 통일되고 의미가 명확해야 함

### 도메인 영역의 주요구성 요소
- 엔티티 : 고유식별자, 라이프사이클을 가짐, 도메인 고유의 개념을 표현
- 밸류 : 도메인 객체의 속성 표현
- 애그리거트 : 엔티티 + 밸류를 개념적으로 하나로 묶음
- 리포지토리 : 도메인 모델의 영속성 처리
- 도메인 서비스 : 도메인 로직이 여러 도메인을 사용해야 할 때 사용

## 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 바라볼 수 있도록 하는 방법
- 관련된 객체를 하나의 군집으로 묶음으로써 도메인의 복잡도 하락
- 애그리거트안의 대부분의 객체는 생성과 소멸을 함께 한다
  - 이러한 기준으로 애그리거트 경계를 나누면 좀 더 쉽게 설계할 수 있음
- 애그리거트는 대부분 하나의 엔티티를 가짐

### 애그리거트 루트
- 애그리거트에 속한 객체를 일관성 있는 상태로 유지하도록 관리하는 객체
- 직.간접적으로 애그리거트의 객체들이 속함
- 애그리거트 루트를 통해서만 도메인 로직 구현해야 함
  - 밸류 타입을 불변하게 만들고, 외부에서 변경할 수 없게 캡슐화하여 애그리거트 루트에서 새로 생성하여 바꾸도록 구현
- 애그리거트 루트를 제외한 객체들을 protected 나 default 로 설정하는 것도 고려해야 함

### 애그리거트 트랜잭션
- 한 트랜잭션에서는 하나의 애그리거트만 수정해야 함 => 충돌 가능성 방지
- 응용 계층에서 두 애그리거트를 수정하도록 구현

### 리포지토리 
- 리포지토리 기술에 따라 애그리거트 구현에 영향이 생김
  - ex) JPA : Value 타입의 도메인 모델에 대해 @Entity 를 사용해야 하는 경우가 있음(table 에 저장)

### 애그리거트 참조
- JPA 를 사용해서 다른 애그리거트를 필드참조로 연관관계를 맺으면 편리하지만 단점도 따름
  1. 편리한 탐색 오용 => 다른 애그리거트를 편리하게 수정하려는 욕구가 생김
  2. 성능 이슈 => lazy 로딩으로 인해 n + 1 등의 문제
  3. 확장 어려움 => 애그리거트끼리 종속성이 생김
- id 를 이용한 참조를 통해 위의 단점을 해결 => lazy 로딩의 효과가 있음
  - n + 1 문제가 발생할 수 있는데 두가지 해결책
    1. 조회전용쿼리 생성
    2. CQRS 패턴 적용
